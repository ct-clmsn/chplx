/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "hpx/symboltypes.hpp"

#include "chpl/uast/all-uast.h"

#include <variant>
#include <fstream>
#include <cctype>
#include <numeric>
#include <type_traits>
#include <filesystem>

#define INDENT "    "

using namespace chpl::uast;
 
namespace chpl { namespace ast { namespace visitors { namespace hpx {

CodegenVisitor::CodegenVisitor(
   chpl::ast::visitors::hpx::SymbolTable & st,
   ProgramTree & prgmTree,
   chpl::uast::BuilderResult const& chapelBr,
   std::string const& chapelFilePath,
   std::ostream & fstrm)
   : symbolTable(st), programTree(prgmTree), br(chapelBr), indent(0), scope(0),
     fstrm_(fstrm),
     chplFilePathStr(chapelFilePath),
     headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false)
{
}

static void upper(std::string & s) {
   std::transform(std::begin(s), std::end(s), std::begin(s), 
      [](const unsigned char c){ return std::toupper(c); } // correct
   );
}

void CodegenVisitor::generateApplicationHeader() {
   const auto pos = chplFilePathStr.find(".");
   std::string prefix = chplFilePathStr.substr(0, pos);

   std::fstream os(prefix + ".hpp", std::ios_base::out);
   upper(prefix);

   os << "// This program file was generated by the chplx compiler." << std::endl;
   os << "// The original Chapel program file can be found here: " << chplFilePathStr << std::endl; 
   os << "//" << std::endl;
   os << "#pragma once" << std::endl << std::endl;
   os << "#ifndef __" << prefix << "_HPP__" << std::endl;
   os << "#define __" << prefix << "_HPP__" << std::endl << std::endl;

   for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
      if(headers[i]) {
         if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
            os << "#include <vector>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
            os << "#include <complex>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
            os << "#include <string>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_iostream)) {
            os << "#include <iostream>" << std::endl;
         }
      }
   }

   os << std::endl << "#endif" << std::endl;

   os.flush();
   os.close();
}

struct FuncDeclArgVisitor {

   template<typename T>
   void operator()(T const&) {
   }
   void operator()(bool_kind const& kind) {
      os << "bool";
   }
   void operator()(byte_kind const&) {
      os << "std::uint8_t";
   }
   void operator()(int_kind const&) {
      os << "std::int64_t";
   }
   void operator()(real_kind const&) {
      os << "double";
   }
   void operator()(complex_kind const&) {
      os << "std::complex<double>";
   }
   void operator()(string_kind const&) {
      os << "std::string";
   }
   void operator()(nil_kind const&) {
      os << "void";
   }

   std::ostream & os;
};

struct ExprVisitor {
    template<typename T>
    void operator()(T const&) {}

    void operator()(LiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(VariableExpression const& node) {
       node.emit(os);
    }
    void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
       const bool lop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[0]);
       const bool rop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[1]);

       if(lop) {
           os << "( ";
       }

       std::visit(ExprVisitor{os}, node->statements[0]);

       if(lop) {
           os << " )";
       }

       os << ' ' << node->op << ' ';

       if(rop) {
           os << "( ";
       }

       std::visit(ExprVisitor{os}, node->statements[1]);

       if(rop) {
           os << " )";
       }
    }
    void operator()(std::shared_ptr<UnaryOpExpression> const& node) {
    }
    std::ostream & os;
};

struct StatementVisitor {
   
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void operator()(std::shared_ptr<StatementList> const& node) {
      auto & list = *node;
      for(auto & stmt : list.statements) {
         std::visit(*this, stmt); 
      }
   }
   void operator()(ScalarDeclarationExpression const& node) {
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ArrayDeclarationExpression const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

      std::shared_ptr<array_kind> const& akref =
         std::get<std::shared_ptr<array_kind>>(node.kind);

      if(!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
            std::holds_alternative<complex_kind>(akref->kind);
      }
      if(!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
            std::holds_alternative<string_kind>(akref->kind);
      }

      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
      os << " = ";
      std::visit(ScalarDeclarationLiteralExpressionVisitor{(*s->literal)[0], os}, node.kind);
      os << ";" << std::endl;
   }
   void operator()(ArrayDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      emitIndent();
      os << node.chplLine << std::endl;
      emitIndent();
      node.emit(os);
   }
   void operator()(std::shared_ptr<ReturnExpression> const& node) {
      emitIndent();
      os << node->chplLine << std::endl;
      emitIndent();
      node->emit(os);
   }
   void operator()(std::shared_ptr<FunctionCallExpression> const& node) {
      if(std::holds_alternative<std::shared_ptr<cxxfunc_kind>>(*node->symbol.kind)) {
         headers[static_cast<std::size_t>(HeaderEnum::std_iostream)] = true;
      }
      emitIndent();
      os << node->chplLine << std::endl;
      emitIndent();
      node->emit(os);
   }
   void operator()(std::shared_ptr<FunctionDeclarationExpression> const& node) {
      if(!node->symbol.identifier) { std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression " << (*(node->symbol.identifier)) << " not found" << std::endl; }
      emitIndent();
      os << node->chplLine << std::endl;
      emitIndent();

      if(std::holds_alternative<std::shared_ptr<func_kind>>(*(node->symbol.kind))) {
         std::shared_ptr<func_kind> const& fk =
            std::get<std::shared_ptr<func_kind>>(*(node->symbol.kind));

         FuncDeclArgVisitor fdav{os};
         std::visit(fdav, *(fk->retKind));

         std::string const& fn_sig_ref =
            (*(node->symbol.identifier));

         const std::size_t pos =
            fn_sig_ref.find("_");

         os << ' ' << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos : fn_sig_ref.size() ) << '(';

         const std::size_t args_sz = fk->args.size()-1;

         if(0 < args_sz) {
            std::visit(fdav, (*(fk->args[0].kind)));
            os << ' ' << (*(fk->args[0].identifier));

            for(std::size_t i = 1; i < args_sz; ++i) {
               os << ',';
               std::visit(fdav, (*(fk->args[i].kind)) );
               os << ' ' << (*(fk->args[i].identifier));
            }
         }

         os << ") {" << std::endl;
         ++indent;
         for(const auto& stmt : node->statements) {
            visit(*this, stmt);
         }
         --indent;
         emitIndent();
         os << '}' << std::endl;
      }
   }
   void operator()(std::shared_ptr<UnaryOpExpression> const& node) {
      emitIndent();
      node->emit(os);
      emitIndent();
   }
   void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
      emitIndent();
      emitChapelLine(os, node->ast);
      emitIndent();

      std::visit(ExprVisitor{os}, node->statements[0]);

      os << ' ' << node->op << ' ';

      std::visit(ExprVisitor{os}, node->statements[1]);

      os << ';' << std::endl;
   }
   void operator()(std::shared_ptr<ForallLoopExpression> const& expr) {
      emitIndent();
      expr->emit(os);
      os << "{";
      for(const auto& stmt : expr->statements) {
         std::visit(*this, stmt);
      }
      os << "}";
   }

   void emitChapelLine(std::ostream & os, uast::AstNode const* ast) const {
      auto fp = br.filePath();
      std::filesystem::path p(fp.c_str());
      os << "#line " << br.idToLocation(ast->id(), fp).line()  << " \"" << p.filename().string() << "\"" << std::endl;
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
};

template<>
void CodegenVisitor::visit(StatementVisitor && v) {
   for(Statement const& stmt : programTree.statements) {
      std::visit(v, stmt);
   }
}

void CodegenVisitor::visit() {
   visit(StatementVisitor{symbolTable, br, fstrm_, indent, headers});
}

} /* namespace hpx */ } /* namespace visitors */ } /* namespace ast */ } /* namespace chpl */
