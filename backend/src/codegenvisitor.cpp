/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "hpx/symboltypes.hpp"
#include "hpx/utils.hpp"

#include "chpl/uast/all-uast.h"

#include <variant>
#include <fstream>
#include <cctype>
#include <numeric>
#include <type_traits>
#include <filesystem>

#define INDENT "    "

using namespace chpl::uast;

// emit line directive
void emitLineDirective(std::filesystem::path const& p, int line);

namespace chpl { namespace ast { namespace visitors { namespace hpx {

CodegenVisitor::CodegenVisitor(
   chpl::ast::visitors::hpx::SymbolTable & st,
   std::vector< Symbol > & configVars,
   ProgramTree & prgmTree,
   chpl::uast::BuilderResult const& chapelBr,
   std::string const& cppFilePath,
   std::string const& chapelFilePath)
   : symbolTable(st), cfgVars(configVars), programTree(prgmTree), br(chapelBr),
     indent(0), scope(0),
     cppFilePathStr(cppFilePath),
     chplFilePathStr(chapelFilePath),
     headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false)
{
}

static void upper(std::string & s) {
   std::transform(std::begin(s), std::end(s), std::begin(s), 
      [](const unsigned char c){ return std::toupper(c); } // correct
   );
}

void CodegenVisitor::generateApplicationHeader(std::string const& chplpth, std::string const& Prefix, std::fstream & os) {
   std::string prefix{Prefix};
   upper(prefix);

   os << "// This program file was generated by the chplx compiler." << std::endl
   << "// The original Chapel program file can be found here: " << chplpth << std::endl
   << "//" << std::endl
   << "#pragma once" << std::endl << std::endl
   << "#ifndef __" << prefix << "_DRIVER_HPP__" << std::endl
   << "#define __" << prefix << "_DRIVER_HPP__" << std::endl << std::endl
   << "#include <chplx.hpp>" << std::endl
   << "#include \"" << Prefix << ".hpp\"" << std::endl;

   for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
      if(headers[i]) {
         if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
            os << "#include <vector>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
            os << "#include <complex>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
            os << "#include <string>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_iostream)) {
            os << "#include <iostream>" << std::endl;
         }
         else if(i == static_cast<std::size_t>(HeaderEnum::std_functional)) {
            os << "#include <functional>" << std::endl;
         }
      }
   }

   os << std::endl << "#endif" << std::endl;

   os.flush();
   os.close();
}

struct FuncDeclArgVisitor {

   FuncDeclArgVisitor(std::ostream & s) : os(s), ret(false), dim(0), inc(0) {}

   template<typename T>
   void operator()(T const&) {
   }
   void reset() { ret = false; dim = 0; inc = 0; }
   void operator()(bool_kind const& kind) {
      if(!ret) {
         os << "bool";
         ret = true;
      }
   }
   void operator()(byte_kind const&) {
      if(!ret) {
         os << "std::uint8_t";
         ret = true;
      }
   }
   void operator()(int_kind const&) {
      if(!ret) {
         os << "std::int64_t";
         ret = true;
      }
   }
   void operator()(real_kind const&) {
      if(!ret) {
         os << "double";
         ret = true;
      }
   }
   void operator()(complex_kind const&) {
      if(!ret) {
         os << "std::complex<double>";
         ret = true;
      }
   }
   void operator()(string_kind const&) {
      if(!ret) {
         os << "std::string";
         ret = true;
      }
   }
   void operator()(nil_kind const&) {
      if(!ret) {
         os << "void";
         ret = true;
      }
   }
   void operator()(auto_kind const&) {
      if(!ret) {
         os << "auto";
         ret = true;
      }
   }
   void enter(std::shared_ptr<array_kind> const& arg) {
      dim += 1;
      inc += 1;

      if(std::holds_alternative<std::shared_ptr<kind_node_type>>(arg->retKind)) {
         auto & rk = std::get<std::shared_ptr<kind_node_type>>(arg->retKind);
         for(auto & c : rk->children) {
            if(std::holds_alternative<nil_kind>(c)) { continue; }
            std::visit(*this, c);
         }
      }
      else {
         std::visit(*this, arg->retKind);
      }
   }
   void exit(std::shared_ptr<array_kind> const& arg) {
      if(0 < dim) {
         dim -= 1;
      }
   }
   void operator()(std::shared_ptr<array_kind> const& arg) {
       if(dim < 1) {
         os << "chplx::Array<";
       }

       enter(arg);
       exit(arg);

       if(dim < 1) {
         inc -= 1;
         os << ", chplx::Domain<" << inc << "> > &";
       }
   }

   std::ostream & os;
   bool ret;   
   std::size_t dim, inc;
};

struct ExprVisitor {
    template<typename T>
    void operator()(T const&) {}

    void operator()(ScalarDeclarationExpression const& node) {
       node.emit(os);
    }
    void operator()(ScalarDeclarationLiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(std::shared_ptr<ScalarDeclarationExprExpression> const& node) {
      node->emit(os);
    }
    void operator()(LiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(VariableExpression const& node) {
       node.emit(os);
    }
    void operator()(std::shared_ptr<FunctionCallExpression> const& node) {
       node->emit(os);
    }
    void operator()(std::shared_ptr<TupleDeclarationExprExpression> const& node) {
       node->emit(os);
    }
    void operator()(TupleDeclarationLiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(ArrayDeclarationLiteralExpression const& node) {
       node.emit(os);
    }
    void operator()(std::shared_ptr<ArrayDeclarationExprExpression> const& node) {
       node->emit(os);
    }
    void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
       if(node->statements.size() == 2) {
          const bool lop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[0]);
          const bool rop = std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[1]);

          if(lop) {
             os << "( ";
          }

          std::visit(ExprVisitor{os}, node->statements[0]);

          if(lop) {
             os << " )";
          }

          os << ' ' << node->op << ' ';

          if(rop) {
             os << "( ";
          }

          std::visit(ExprVisitor{os}, node->statements[1]);

          if(rop) {
             os << " )";
          }
       }
       else if(node->statements.size() == 1) {
          os << ' ' << node->op;
          std::visit(ExprVisitor{os}, node->statements[0]);
       }
    }

    std::ostream & os;
};

struct HppStatementVisitor {
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void prologue(std::shared_ptr<ModuleDeclarationExpression> const& node) {
      if(node->symbol.identifier.size() < 1) { std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression " << node->symbol.identifier << " not found" << std::endl; }

      if(std::holds_alternative<std::shared_ptr<module_kind>>(node->symbol.kind)) {
         std::shared_ptr<module_kind> const& fk =
            std::get<std::shared_ptr<module_kind>>(node->symbol.kind);

         std::string prefix{fk->symbolTableSignature};
         upper(prefix);
 
         os << "// This program file was generated by the chplx compiler." << std::endl
            << "// The original Chapel program file can be found here: " << fk->symbolTableSignature << ".chpl" << std::endl
            << "//" << std::endl
            << "#pragma once" << std::endl << std::endl
            << "#ifndef __" << prefix << "_HPP__" << std::endl
            << "#define __" << prefix << "_HPP__" << std::endl << std::endl
            << "#include <chplx.hpp>" << std::endl;

         for(std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount); ++i) {
            if(headers[i]) {
               if(i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
                  os << "#include <vector>" << std::endl;
               }
               else if(i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
                  os << "#include <complex>" << std::endl;
               }
               else if(i == static_cast<std::size_t>(HeaderEnum::std_string)) {
                  os << "#include <string>" << std::endl;
               }
               else if(i == static_cast<std::size_t>(HeaderEnum::std_iostream)) {
                  os << "#include <iostream>" << std::endl;
               }
               else if(i == static_cast<std::size_t>(HeaderEnum::std_functional)) {
                  os << "#include <functional>" << std::endl;
               }
            }
         }

         if(printChplLine) {
            os << node->chplLine;
         }

         os << "namespace " << fk->symbolTableSignature << " {" << std::endl;
      }
   }

   void epilogue() {
      os << std::endl << "} // end namespace" << std::endl << std::endl << "#endif" << std::endl;
   }

   void operator()(ScalarDeclarationExpression const& node) {
      if(!node.config) { return; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }

      os << "extern ";

      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      if(!node.config) { return; }
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }

      os << "extern ";

      node.emit(os);

      os << ";" << std::endl;
   }
   void operator()(std::shared_ptr<ScalarDeclarationExprExpression> const& node) {
      if(!node->config) { return; }
      std::optional<Symbol> s = symbolTable.find(node->scopeId, node->identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationExprExpression " << node->identifier << " not found" << std::endl; }

      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }

      os << "extern ";

      node->emit(os);

      os << ';' << std::endl;
   }
   void operator()(std::shared_ptr<FunctionDeclarationExpression> const& node) {
      if(node->symbol.identifier.size() < 1) { std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression " << node->symbol.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent(); emitIndent();
         os << node->chplLine;
         emitIndent();
      }

      emitIndent();
      if(std::holds_alternative<std::shared_ptr<func_kind>>(node->symbol.kind)) {
         std::shared_ptr<func_kind> const& fk =
            std::get<std::shared_ptr<func_kind>>(node->symbol.kind);

         const std::size_t args_sz = fk->args.size()-1;
         FuncDeclArgVisitor fdav{os};
         std::visit(fdav, fk->retKind);
         fdav.reset();

         std::string const& fn_sig_ref =
            node->symbol.identifier;
         const std::size_t pos =
            fn_sig_ref.find("|");

         os << ' ' << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos : fn_sig_ref.size() ) << "(";

         if(0 < args_sz) {
            std::visit(fdav, fk->args[0].kind);
            fdav.reset();
            os << ' ' << fk->args[0].identifier;
            for(std::size_t i = 1; i < args_sz; ++i) {
               if(std::holds_alternative<nil_kind>(fk->args[i].kind)) { continue; }
               os << ',';
               std::visit(fdav, fk->args[i].kind );
               fdav.reset();
               os << ' ' << fk->args[i].identifier;
            }
         }

         if(std::holds_alternative<nil_kind>(fk->retKind)) {
            os << ")";
         }
         else {
            os << ")";
         }

         os << ";" << std::endl;
      }
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
   bool printChplLine;
   bool arg;
};

struct StatementVisitor {
   
   void emitIndent() const {
      for(std::size_t i = 0; i < indent; ++i) {
         os << INDENT; 
      }
   }

   template <typename T>
   constexpr void operator()(T const& kind) {}

   void operator()(std::shared_ptr<StatementList> const& node) {
      auto & list = *node;
      for(auto & stmt : list.statements) {
         std::visit(*this, stmt); 
      }
   }
   void operator()(ScalarDeclarationExpression const& node) {
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(ArrayDeclarationExpression const& node) {
/*
      headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

      std::shared_ptr<array_kind> const& akref =
         std::get<std::shared_ptr<array_kind>>(node.kind);

      if(!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
            std::holds_alternative<complex_kind>(akref->kind);
      }
      if(!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
         headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
            std::holds_alternative<string_kind>(akref->kind);
      }

*/
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(ScalarDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
      if( 0 < node.literalValue.size() ) {
         os << " = ";
         std::visit(ScalarDeclarationLiteralExpressionVisitor{node.literalValue[0], os}, node.kind);
      }
      os << ";" << std::endl;
   }
   void operator()(ArrayDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ArrayDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(std::shared_ptr<ArrayDeclarationExprExpression> const& node) {
      std::optional<Symbol> s = symbolTable.find(node->scopeId, node->identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ArrayDeclarationExprExpression " << node->identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();
      node->emit(os);
   }
   void operator()(TupleDeclarationExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp TupleDeclarationExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(TupleDeclarationLiteralExpression const& node) {
      std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp TupleDeclarationLiteralExpression " << node.identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node.chplLine;
      }
      emitIndent();
      node.emit(os);
   }
   void operator()(std::shared_ptr<TupleDeclarationExprExpression> const& node) {
      std::optional<Symbol> s = symbolTable.find(node->scopeId, node->identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp TupleDeclarationExprExpression " << node->identifier << " not found" << std::endl; }
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();
      node->emit(os);
   }
   void operator()(VariableExpression const& node) {
      if(arg) {
         node.emit(os);
      }
   }
   void operator()(std::shared_ptr<ConditionalExpression> const& node) {
      for(std::size_t i = 0; i < node->exprs.size(); ++i) {
         if(printChplLine) {
            emitIndent();
            emitChapelLine(os, node->exprs[i].node);
         }
         emitIndent();
         os << ( (i == 0) ? "if" : ( (0 < node->exprs[i].conditions.size()) ?  "else if" : "else" ) );
         printChplLine = false;
         arg = true;
         if(0 < node->exprs[i].conditions.size()) {
            os << '(';
            visit(*this, node->exprs[i].conditions[0]);
            os << ")";
         }
         printChplLine = true;
         arg = false;
         os << "{" << std::endl;
         ++indent;
         for(const auto& stmt : node->exprs[i].statements) {
            visit(*this, stmt);
         }
         --indent;
         emitIndent();
         os << "}" << std::endl;
      }
   }
   void operator()(std::shared_ptr<ForLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      //auto const& rk = std::get<std::shared_ptr<range_kind>>(node->indexSet.kind);
      //auto & indices = rk->args;

      os << "chplx::forLoop(chplx::Range{";
      if(node->indexSet.size() == 1) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
      }
      else if(node->indexSet.size() == 2) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
          os << ',';
          std::visit(ev, node->indexSet[1]);
      }
      else {
         assert(node->indexSet.size() < 3);
      }
/*
      if(std::holds_alternative<int_kind>(indices[0].kind)) {
         if(indices[0].identifier.size() < 1 || indices[0].identifier.find("lit") != std::string::npos) {
            os << int_kind::value(indices[0].literal[0]);
         }
         else {
            os << indices[0].identifier;
         }
      }

      os << ", ";
      if(std::holds_alternative<int_kind>(indices[1].kind)) {
         if(indices[1].identifier.size() < 1 || indices[1].identifier.find("lit") != std::string::npos) {
            os << int_kind::value(indices[1].literal[0]);
         }
         else {
            os << indices[1].identifier;
         }
      }
*/
      os << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;

      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<ForallLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      // replace with statements
      //
      //auto const& rk = std::get<std::shared_ptr<range_kind>>(node->indexSet.kind);
      //auto & indices = rk->args;

      os << "chplx::forall(HPX_CURRENT_SOURCE_LOCATION(), chplx::Range{";

      if(node->indexSet.size() == 1) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
      }
      else if(node->indexSet.size() == 2) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
          os << ',';
          std::visit(ev, node->indexSet[1]);
      }
      else {
         assert(node->indexSet.size() < 3);
      }
/*
      if(std::holds_alternative<int_kind>(indices[0].kind)) {
         if(indices[0].identifier.size() < 1 || indices[0].identifier.find("lit") != std::string::npos) {
            os << int_kind::value(indices[0].literal[0]);
         }
         else {
            os << indices[0].identifier;
         }
      }

      os << ", ";
      if(std::holds_alternative<int_kind>(indices[1].kind)) {
         if(indices[1].identifier.size() < 1 || indices[1].identifier.find("lit") != std::string::npos) {
            os << int_kind::value(indices[1].literal[0]);
         }
         else {
            os << indices[1].identifier;
         }
      }
*/
      os << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;

      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<CoforallLoopExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();

      //auto const& rk = std::get<std::shared_ptr<range_kind>>(node->indexSet.kind);
      //auto & indices = rk->args;

      os << "chplx::coforall(HPX_CURRENT_SOURCE_LOCATION(), chplx::Range{";
/*
      if(std::holds_alternative<int_kind>(indices[0].kind)) {
         os << int_kind::value(indices[0].literal[0]);
      }

      os << ", ";
      if(std::holds_alternative<int_kind>(indices[0].kind)) {
         os << int_kind::value(indices[1].literal[0]);
      }
*/
      if(node->indexSet.size() == 1) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
      }
      else if(node->indexSet.size() == 2) {
          ExprVisitor ev{os};
          std::visit(ev, node->indexSet[0]);
          os << ',';
          std::visit(ev, node->indexSet[1]);
      }
      else {
         assert(node->indexSet.size() < 3);
      }

      os << "}, [&](auto " << node->iterator.identifier << ") {" << std::endl;
      ++indent;
      for(const auto& stmt : node->statements) {
         visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << "});" << std::endl;
   }
   void operator()(std::shared_ptr<ReturnExpression> const& node) {
      emitIndent();
      os << node->chplLine;
      emitIndent();
      node->emit(os);
   }
   void operator()(std::shared_ptr<FunctionCallExpression> const& node) {
      const bool is_cxx = std::holds_alternative<std::shared_ptr<cxxfunc_kind>>(node->symbol.kind);
      if(is_cxx) {
         headers[static_cast<std::size_t>(HeaderEnum::std_iostream)] = true;
      }
      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }
      emitIndent();
      node->emit(os);
      if(!is_cxx) {
         os << ';' << std::endl;
      }
   }
   void operator()(std::shared_ptr<FunctionDeclarationExpression> const& node) {
      headers[static_cast<std::size_t>(HeaderEnum::std_functional)] = true;

      if(node->symbol.identifier.size() < 1) { std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression " << node->symbol.identifier << " not found" << std::endl; }

      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
         emitIndent();
      }

      if(std::holds_alternative<std::shared_ptr<func_kind>>(node->symbol.kind)) {
         std::shared_ptr<func_kind> const& fk =
            std::get<std::shared_ptr<func_kind>>(node->symbol.kind);

         const std::size_t args_sz = fk->args.size()-1;
         FuncDeclArgVisitor fdav{os};

         if(moduleLevel) {
            std::visit(fdav, fk->retKind);
            fdav.reset();
            std::string const& fn_sig_ref =
               node->symbol.identifier;

            const std::size_t pos =
               fn_sig_ref.find("|");

            os << " __thisModule::" << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos : fn_sig_ref.size() ) << "(";

            if(0 < args_sz) {
               std::visit(fdav, fk->args[0].kind);
               fdav.reset();
               os << ' ' << fk->args[0].identifier;

               for(std::size_t i = 1; i < args_sz; ++i) {
                  if(std::holds_alternative<nil_kind>(fk->args[i].kind)) { continue; }
                  os << ',';
                  std::visit(fdav, fk->args[i].kind );
                  fdav.reset();
                  os << ' ' << fk->args[i].identifier;
               }
            }

            if(std::holds_alternative<nil_kind>(fk->retKind)) {
               os << ")";
            }
            else {
               os << ")";
            }
         }
         else {
            os << "auto ";
            std::string const& fn_sig_ref =
               node->symbol.identifier;

            const std::size_t pos =
               fn_sig_ref.find("|");

            os << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos : fn_sig_ref.size() ) << " = [&](";

            if(0 < args_sz) {
               std::visit(fdav, fk->args[0].kind);
               fdav.reset();
               os << ' ' << fk->args[0].identifier;

               for(std::size_t i = 1; i < args_sz; ++i) {
                  os << ',';
                  std::visit(fdav, fk->args[i].kind );
                  fdav.reset();
                  os << ' ' << fk->args[i].identifier;
               }
            }

            if(std::holds_alternative<nil_kind>(fk->retKind)) {
               os << ")";
            }
            else {
               os << ") -> ";
               std::visit(fdav, fk->retKind);
               fdav.reset();
            }
         }

         os << " {";
         os << std::endl;
         ++indent;
         for(const auto& stmt : node->statements) {
            visit(*this, stmt);
         }
         --indent;
         emitIndent();
         os << "};" << std::endl;
      }
   }
   void operator()(std::shared_ptr<UnaryOpExpression> const& node) {
      emitIndent();
      node->emit(os);
      emitIndent();
   }
   void operator()(std::shared_ptr<BinaryOpExpression> const& node) {
      if(printChplLine) {
         emitIndent();
         if(node->statements.size() &&
            !std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(node->statements[0])) {
            emitChapelLine(os, node->ast);
         }

         if(node->statements.size() &&
            std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(node->statements[0])) {
            auto & sdee = std::get<std::shared_ptr<ScalarDeclarationExprExpression>>(node->statements[0]);
            os << sdee->chplLine;
         }
      }

      if(!arg) {
         emitIndent();
      }

      std::visit(ExprVisitor{os}, node->statements[0]);

      os << ' ' << node->op << ' ';

      if(std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(node->statements[0])) {
         auto & sdee = std::get<std::shared_ptr<ScalarDeclarationExprExpression>>(node->statements[0]);
         if(sdee->statements.size()) {
            std::visit(ExprVisitor{os}, sdee->statements[0]);
            os << ';' << std::endl;
            if(1 < node->statements.size()) {
               emitIndent();
            }
         }
      }

      if(std::holds_alternative<std::shared_ptr<ArrayDeclarationExprExpression>>(node->statements[0])) {
         auto & adee = std::get<std::shared_ptr<ArrayDeclarationExprExpression>>(node->statements[0]);
         os << "chplx::Array<>{";
         for(auto i = 0; i < adee->statements.size(); ++i) {
            std::visit(ExprVisitor{os}, adee->statements[i]);
            if(i != adee->statements.size()-1) {
               os << ',';
            }
         }
        
         os << "}";
      }
      else {
         for(auto i = 1; i < node->statements.size(); ++i) {
            std::visit(ExprVisitor{os}, node->statements[i]);
            if(i != node->statements.size()-1) {
               os << ',';
            }
         }
      }

      if(!arg) {
         os << ';' << std::endl;
      }
   }
   void operator()(std::shared_ptr<ScalarDeclarationExprExpression> const& node) {
      if( node->statements.size() < 1) {
         std::cerr << node->chplLine << std::endl;
         assert(node->statements.size());
      }
      std::optional<Symbol> s = symbolTable.find(node->scopeId, node->identifier);
      if(!s) { std::cerr << "codegenvisitor.cpp ScalarDeclarationExprExpression " << node->identifier << " not found" << std::endl; }

      if(printChplLine) {
         emitIndent();
         os << node->chplLine;
      }

      emitIndent();
      if(std::holds_alternative<std::shared_ptr<BinaryOpExpression>>(node->statements[0])) {
         std::visit(ExprVisitor{os}, node->statements[0]);
      }
      else {
         node->emit(os);
         os << " = ";
         std::visit(ExprVisitor{os}, node->statements[0]);
      }

      if(!arg) {
         os << ';' << std::endl;
      }
   }
   void operator()(std::shared_ptr<RecordDeclarationExpression> const& node) {
      // populate prologue of template
      os << "record " << node->symbol.identifier << " {" << std::endl;
      for(Statement const& stmt : node->statements) {
         std::visit(*this, stmt);
      }
      // populate epilogue of template
      os << std::endl << "}" << std::endl;
   }
   void operator()(std::shared_ptr<ClassDeclarationExpression> const& node) {
      // populate prologue of template
      os << "class " << node->symbol.identifier << " {" << std::endl;
      for(Statement const& stmt : node->statements) {
         std::visit(*this, stmt);
      }
      // populate epilogue of template
      os << std::endl << "}" << std::endl;
   }
   void operator()(std::shared_ptr<ModuleDeclarationExpression> const& node) {
      // needs to open a file and generate the module template provided by HK
      //
      
      std::filesystem::path ofile = chplx::util::output_path / node->symbol.identifier;
      std::fstream cppofs(ofile.string() + ".cpp", std::ios_base::out);
      StatementVisitor cppv{symbolTable, br, cppofs, indent, headers, true, false, true};

      // populate prologue of template

      const std::size_t statements_size = node->statements.size();
      std::vector<std::size_t> main_scoped_statements{};
      std::vector<std::size_t> fn_statements{};
      {
         cppofs << "// This program file was generated by the chplx compiler." << std::endl
                << "// The original Chapel program file can be found here: " << node->symbol.identifier << ".chpl" << std::endl
                << "//" << std::endl
                << "#include \"" << node->symbol.identifier << ".hpp\"" << std::endl << std::endl
                << "namespace " << node->symbol.identifier << " {" << std::endl << std::endl;

         cppv.emitIndent();
         cppofs << "struct __thisModule *__this = nullptr;" << std::endl << std::endl;
         cppv.emitIndent();

         for(std::size_t i = 0; i < statements_size; ++i) {
            auto const& stmt = node->statements[i];
/*
            if(
               std::holds_alternative<std::shared_ptr<RecordDeclarationExpression>>(stmt) ||
               std::holds_alternative<std::shared_ptr<ClassDeclarationExpression>>(stmt)
            ) {
               std::visit(cppv, stmt);
            }
*/
            if(
               (std::holds_alternative<ScalarDeclarationExpression>(stmt) && std::get<ScalarDeclarationExpression>(stmt).config) ||
               (std::holds_alternative<ScalarDeclarationLiteralExpression>(stmt) && std::get<ScalarDeclarationLiteralExpression>(stmt).config) ||
               (std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt) && std::get<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt)->config)
            ) {
               continue;
            }
            else if(
               std::holds_alternative<std::shared_ptr<FunctionDeclarationExpression>>(stmt)
            ) {
                fn_statements.push_back(i);
            }
            else {
                main_scoped_statements.push_back(i);
            }
         }

         cppofs << std::endl;
      }

      for(const std::size_t i : fn_statements) {
         auto const& stmt = node->statements[i];
         std::visit(cppv, stmt);
         cppofs << std::endl;
      }

      for(std::size_t i = 0; i < statements_size; ++i) {
         auto const& stmt = node->statements[i];
         if(
            (std::holds_alternative<ScalarDeclarationExpression>(stmt) && std::get<ScalarDeclarationExpression>(stmt).config) ||
            (std::holds_alternative<ScalarDeclarationLiteralExpression>(stmt) && std::get<ScalarDeclarationLiteralExpression>(stmt).config) ||
            (std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt) && std::get<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt)->config)
         ) {
            std::visit(cppv, stmt);
         }
      }

      cppofs << std::endl;

      // populate main scope of module 
      //
      cppv.emitIndent();

      cppofs << "void __thisModule::__main() {" << std::endl << std::endl;

      for(const std::size_t i : main_scoped_statements) {
         auto const& stmt = node->statements[i];
         std::visit(cppv, stmt);
      }

      cppofs << std::endl << std::endl;
      cppv.emitIndent();
      cppofs << '}' << std::endl << std::endl;
      cppofs << "} // end namespace";

      // populate hpp
      //
      std::fstream hppofs(ofile.string() + ".hpp", std::ios_base::out);
      HppStatementVisitor hppv{symbolTable, br, hppofs, indent, headers, true, false};
      hppv.prologue(node);

      hppv.emitIndent();
      hppofs << "extern struct __thisModule *__this;" << std::endl << std::endl;

      for(std::size_t i = 0; i < statements_size; ++i) {
         auto const& stmt = node->statements[i];
         if(
            (std::holds_alternative<ScalarDeclarationExpression>(stmt) && std::get<ScalarDeclarationExpression>(stmt).config) ||
            (std::holds_alternative<ScalarDeclarationLiteralExpression>(stmt) && std::get<ScalarDeclarationLiteralExpression>(stmt).config) ||
            (std::holds_alternative<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt) && std::get<std::shared_ptr<ScalarDeclarationExprExpression>>(stmt)->config)
         ) {
            std::visit(hppv, stmt);
         }
      }

      hppofs << std::endl << std::endl;

      hppv.emitIndent();

      hppofs << "struct __thisModule {" << std::endl << std::endl;

      for(std::size_t i = 0; i < statements_size; ++i) {
         auto const& stmt = node->statements[i];
         if(
            std::holds_alternative<std::shared_ptr<FunctionDeclarationExpression>>(stmt) ||
            std::holds_alternative<std::shared_ptr<RecordDeclarationExpression>>(stmt) ||
            std::holds_alternative<std::shared_ptr<ClassDeclarationExpression>>(stmt) ||
            std::holds_alternative<std::shared_ptr<FunctionDeclarationExpression>>(stmt)
         ) {
            std::visit(hppv, stmt);
         }
      }
      hppofs << std::endl;
      hppv.emitIndent(); hppv.emitIndent();
      hppofs << "static void __construct() { " << node->symbol.identifier << "::__this = new __thisModule(); }" << std::endl << std::endl;
      hppv.emitIndent(); hppv.emitIndent();
      hppofs << "static void __destruct() noexcept {" << std::endl;
      hppv.emitIndent(); hppv.emitIndent(); hppv.emitIndent();
      hppofs << "auto *m = " << node->symbol.identifier <<  "::__this;" << std::endl;
      hppv.emitIndent(); hppv.emitIndent(); hppv.emitIndent();
      hppofs << node->symbol.identifier << "::__this = nullptr;" << std::endl;
      hppv.emitIndent(); hppv.emitIndent(); hppv.emitIndent();
      hppofs << "delete m;" << std::endl;
      hppv.emitIndent(); hppv.emitIndent();
      hppofs << "}" << std::endl << std::endl;
      hppv.emitIndent(); hppv.emitIndent();
      hppofs << "void __main();" << std::endl;

      hppv.emitIndent();
      hppofs << "}; // end struct __thisModule" << std::endl;
      hppv.epilogue();
   }

   void emitChapelLine(std::ostream & os, uast::AstNode const* ast) const {
      auto const fp = br.filePath();
      os << chplx::util::emitLineDirective(fp.c_str(), br.idToLocation(ast->id(), fp).line());
   }

   SymbolTable & symbolTable;
   chpl::uast::BuilderResult const& br;
   std::ostream & os;
   std::size_t indent;
   std::vector<bool> & headers;
   bool printChplLine;
   bool arg;
   bool moduleLevel;
};

template<>
void CodegenVisitor::visit(StatementVisitor && v) {
   for(Statement const& stmt : programTree.statements) {
      std::visit(v, stmt);
   }
}

void VisitQualifierPrefix(std::ostream & os, const int qualifier) {
   if(qualifier == 1) {
      os << "const ";
   }
   else if(qualifier == 4) {
      os << "const ";
   }
}

void VisitQualifierSuffix(std::ostream & os, const int qualifier) {
   if(qualifier == 2) {
      os << " const&";
   }
   else if(qualifier == 3) {
      os << "&";
   }
   else if(qualifier == 6) {
      os << "&";
   }
   else if(qualifier == 7) {
      os << " const&";
   }
   else if(qualifier == 8) {
      os << "&";
   }
   else if(qualifier == 9) {
      os << "&";
   }
}

static void generateSourceHeader(std::vector<Symbol> & cfgVars, std::ostream & fos, std::string const& prefix, std::string const& chplFile) {
   fos << "// This program file was generated by the chplx compiler." << std::endl;
   fos << "// The original Chapel program file can be found here: " << chplFile << std::endl;
   fos << "//" << std::endl;
            
   fos << "#include <hpx/hpx_init.hpp>" << std::endl;
   if(0 < cfgVars.size()) {
      fos << "#include <hpx/program_options.hpp>" << std::endl;
   }
   fos << std::endl;

   {        
      fos << "#include \"" << prefix << "_driver.hpp\"" << std::endl << std::endl;
      fos << "using namespace " << prefix << ';' << std::endl;
   }        
}
   
static void buildFullNamespaceString(std::string & str, SymbolTable & symtable, Symbol & sym) {
   std::size_t moduleidx = symtable.lut[sym.scopeId]->parentModuleId;
   str = symtable.modules[moduleidx]->identifier + "::" + str;

   while(symtable.lut[symtable.modules[moduleidx]->scopeId]->parentModuleId != moduleidx) {
      str = symtable.modules[moduleidx]->identifier + "::" + str;
      moduleidx = symtable.lut[symtable.modules[moduleidx]->scopeId]->parentModuleId;
   }
}

static void generateSourceFooter(std::string const& modStr, SymbolTable & symtable, std::vector<Symbol> & cfgVars, std::ostream & fos) {
   fos << std::endl
       << "int main(int argc, char * argv[]) {" << std::endl
       << "    chplx::registerModule<" << modStr << "::__thisModule>();" << std::endl;

   if(0 < cfgVars.size()) {
      fos << "    hpx::program_options::options_description options;\n    options.add_options()";
      for(auto & opt : cfgVars) {
         fos << std::endl << "        (\"" << opt.identifier << "\"," << std::endl;
         FuncDeclArgVisitor v{fos};
         fos << "            hpx::program_options::value";

         std::string opt_identifier{opt.identifier};
         buildFullNamespaceString(opt_identifier, symtable, opt);

         fos << "(&" << opt_identifier << "), " << "\"config ";
         if(0 < opt.kindqualifier) { VisitQualifierPrefix(fos, opt.kindqualifier); } else { fos <<  "var "; }
         fos << opt.identifier << " : ";
         std::visit(v, opt.kind);
         fos << "\")";
      }
      fos << ';' << std::endl;
      fos << "    hpx::init_params init_args;" << std::endl << "    init_args.desc_cmdline = options;" << std::endl;
   }

   fos << "    return hpx::init(argc, argv" << ((0 < cfgVars.size()) ? ", init_args" : "") <<  ");" << std::endl
       << "}" << std::endl;
}        
   
static void generateHpxMain(std::ostream & fos, std::string const& moduleStr)  {
   fos << std::endl
       << "int hpx_main(int argc, char * argv[]) {" << std::endl
       << "    " << moduleStr << "::__this->__main();" << std::endl
       << "    return hpx::finalize();" << std::endl
       << "}" << std::endl;
}

void CodegenVisitor::visit() {

   // generate cpp code `filename_driver.cpp`
   //    - figure this out...
   //
   std::string fn{};

   if(chplx::util::fullFilePath) {
      fn = chplFilePathStr;
   }
   else {
      fn = std::filesystem::path(chplFilePathStr).filename().string();
   }

   const auto pos = fn.find(".");
   std::string prefix = fn.substr(0, pos);
   std::filesystem::path ofile = chplx::util::output_path / prefix;
   {
      std::fstream ofs(ofile.string() + "_driver.hpp", std::ios_base::out);
      generateApplicationHeader(fn, prefix, ofs);
   }

   {
      std::fstream ofs(ofile.string() + "_driver.cpp", std::ios_base::out);
      generateSourceHeader(cfgVars, ofs, prefix, fn);
      generateHpxMain(ofs, prefix);
      generateSourceFooter(prefix, symbolTable, cfgVars, ofs);
   }

   {
      // rootos is intentionally empty/null
      //
      std::ostream rootos{0};

      // generate cpp code for each module from the program tree
      //
      visit(StatementVisitor{symbolTable, br, rootos, indent, headers, true, false});
   }

}

} /* namespace hpx */ } /* namespace visitors */ } /* namespace ast */ } /* namespace chpl */
