/*
 * Copyright (c) 2023 Hartmut Kaiser
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/codegenvisitor.hpp"
#include "hpx/symboltypes.hpp"

#include "chpl/uast/all-uast.h"

#include <cctype>
#include <fstream>
#include <numeric>
#include <type_traits>
#include <variant>

#define INDENT "    "

using namespace chpl::uast;

namespace chpl {
namespace ast {
namespace visitors {
namespace hpx {

CodegenVisitor::CodegenVisitor(chpl::ast::visitors::hpx::SymbolTable &st,
                               ProgramTree &prgmTree,
                               chpl::uast::BuilderResult const &chapelBr,
                               std::string const &chapelFilePath,
                               std::ostream &fstrm)
    : symbolTable(st), programTree(prgmTree), br(chapelBr), indent(0), scope(0),
      fstrm_(fstrm), chplFilePathStr(chapelFilePath),
      headers(static_cast<std::size_t>(HeaderEnum::HeaderCount), false) {}

static void upper(std::string &s) {
  std::transform(
      std::begin(s), std::end(s), std::begin(s),
      [](const unsigned char c) { return std::toupper(c); } // correct
  );
}

void CodegenVisitor::generateApplicationHeader() {
  const auto pos = chplFilePathStr.find(".");
  std::string prefix = chplFilePathStr.substr(0, pos);

  std::fstream os(prefix + ".hpp", std::ios_base::out);
  upper(prefix);

  os << "// This program file was generated by the chplx compiler."
     << std::endl;
  os << "// The original Chapel program file can be found here: "
     << chplFilePathStr << std::endl;
  os << "//" << std::endl;
  os << "#pragma once" << std::endl << std::endl;
  os << "#ifndef __" << prefix << "_HPP__" << std::endl;
  os << "#define __" << prefix << "_HPP__" << std::endl << std::endl;

  for (std::size_t i = 0; i < static_cast<std::size_t>(HeaderEnum::HeaderCount);
       ++i) {
    if (headers[i]) {
      if (i == static_cast<std::size_t>(HeaderEnum::std_vector)) {
        os << "#include <vector>" << std::endl;
      } else if (i == static_cast<std::size_t>(HeaderEnum::std_complex)) {
        os << "#include <complex>" << std::endl;
      } else if (i == static_cast<std::size_t>(HeaderEnum::std_string)) {
        os << "#include <string>" << std::endl;
      } else if (i == static_cast<std::size_t>(HeaderEnum::std_iostream)) {
        os << "#include <iostream>" << std::endl;
      }
    }
  }

  os << std::endl << "#endif" << std::endl;

  os.flush();
  os.close();
}

struct FuncDeclArgVisitor {

  template <typename T> void operator()(T const &) {}
  void operator()(bool_kind const &kind) { os << "bool"; }
  void operator()(byte_kind const &) { os << "std::uint8_t"; }
  void operator()(int_kind const &) { os << "std::int64_t"; }
  void operator()(real_kind const &) { os << "double"; }
  void operator()(complex_kind const &) { os << "std::complex<double>"; }
  void operator()(string_kind const &) { os << "std::string"; }
  void operator()(nil_kind const &) { os << "void"; }

  std::ostream &os;
};

struct StatementVisitor {

  void emitIndent() const {
    for (std::size_t i = 0; i < indent; ++i) {
      os << INDENT;
    }
  }

  template <typename T> constexpr void operator()(T const &kind) {}

  void operator()(std::shared_ptr<StatementList> const &node) {
    auto &list = *node;
    for (auto &stmt : list.statements) {
      std::visit(*this, stmt);
    }
  }
  void operator()(ScalarDeclarationExpression const &node) {
    emitIndent();
    os << node.chplLine << std::endl;
    emitIndent();
    node.emit(os);
  }
  void operator()(ArrayDeclarationExpression const &node) {
    headers[static_cast<std::size_t>(HeaderEnum::std_vector)] = true;

    std::shared_ptr<array_kind> const &akref =
        std::get<std::shared_ptr<array_kind>>(node.kind);

    if (!headers[static_cast<std::size_t>(HeaderEnum::std_complex)]) {
      headers[static_cast<std::size_t>(HeaderEnum::std_complex)] =
          std::holds_alternative<complex_kind>(akref->kind);
    }
    if (!headers[static_cast<std::size_t>(HeaderEnum::std_string)]) {
      headers[static_cast<std::size_t>(HeaderEnum::std_string)] =
          std::holds_alternative<string_kind>(akref->kind);
    }

    emitIndent();
    os << node.chplLine << std::endl;
    emitIndent();
    node.emit(os);
  }
  void operator()(ScalarDeclarationLiteralExpression const &node) {
    std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
    if (!s) {
      std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression "
                << node.identifier << " not found" << std::endl;
    }
    emitIndent();
    os << node.chplLine << std::endl;
    emitIndent();
    node.emit(os);
    os << " = ";
    std::visit(ScalarDeclarationLiteralExpressionVisitor{(*s->literal)[0], os},
               node.kind);
    os << ";" << std::endl;
  }
  void operator()(ArrayDeclarationLiteralExpression const &node) {
    std::optional<Symbol> s = symbolTable.find(node.scopeId, node.identifier);
    if (!s) {
      std::cerr << "codegenvisitor.cpp ScalarDeclarationLiteralExpression "
                << node.identifier << " not found" << std::endl;
    }
    emitIndent();
    os << node.chplLine << std::endl;
    emitIndent();
    node.emit(os);
  }
  void operator()(std::shared_ptr<FunctionCallExpression> const &node) {
    if (std::holds_alternative<std::shared_ptr<cxxfunc_kind>>(
            *node->symbol.kind)) {
      headers[static_cast<std::size_t>(HeaderEnum::std_iostream)] = true;
    }
    emitIndent();
    os << node->chplLine << std::endl;
    emitIndent();
    node->emit(os);
  }
  void operator()(std::shared_ptr<FunctionDeclarationExpression> const &node) {
    if (!node->symbol.identifier) {
      std::cerr << "codegenvisitor.cpp FunctionDeclarationExpression "
                << (*(node->symbol.identifier)) << " not found" << std::endl;
    }
    emitIndent();
    os << node->chplLine << std::endl;
    emitIndent();

    if (std::holds_alternative<std::shared_ptr<func_kind>>(
            *(node->symbol.kind))) {
      std::shared_ptr<func_kind> const &fk =
          std::get<std::shared_ptr<func_kind>>(*(node->symbol.kind));

      FuncDeclArgVisitor fdav{os};
      std::visit(fdav, *(fk->retKind));

      std::string const &fn_sig_ref = (*(node->symbol.identifier));

      const std::size_t pos = fn_sig_ref.find("_");

      os << ' '
         << fn_sig_ref.substr(0, (pos != std::string::npos) ? pos
                                                            : fn_sig_ref.size())
         << '(';

      const std::size_t args_sz = fk->args.size() - 1;

      if (0 < args_sz) {
        std::visit(fdav, (*(fk->args[0].kind)));
        os << ' ' << (*(fk->args[0].identifier));

        for (std::size_t i = 1; i < args_sz; ++i) {
          os << ',';
          std::visit(fdav, (*(fk->args[i].kind)));
          os << ' ' << (*(fk->args[i].identifier));
        }
      }

      os << ") {" << std::endl;
      ++indent;
      for (const auto &stmt : node->statements) {
        visit(*this, stmt);
      }
      --indent;
      emitIndent();
      os << '}' << std::endl;
    }
  }
  void operator()(std::shared_ptr<BinaryOpExpression> const &node) {
    emitIndent();
    node->emit(os);
    emitIndent();
  }
  void operator()(std::shared_ptr<ForallLoopExpression> const &expr) {
    emitIndent();
    expr->emit(os);
    os << "{";
    for (const auto &stmt : expr->statements) {
      std::visit(*this, stmt);
    }
    os << "}";
  }

  SymbolTable &symbolTable;
  chpl::uast::BuilderResult const &br;
  std::ostream &os;
  std::size_t indent;
  std::vector<bool> &headers;
};

template <> void CodegenVisitor::visit(StatementVisitor &&v) {
  for (Statement const &stmt : programTree.statements) {
    std::visit(v, stmt);
  }
}

void CodegenVisitor::visit() {
  visit(StatementVisitor{symbolTable, br, fstrm_, indent, headers});
}

} /* namespace hpx */
} /* namespace visitors */
} /* namespace ast */
} /* namespace chpl */
