/*
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */

#include "chpl/framework/Context.h"
#include "chpl/framework/Location.h"
#include "chpl/framework/UniqueString.h"
#include "chpl/parsing/parsing-queries.h"
#include "chpl/resolution/resolution-queries.h"
#include "chpl/uast/all-uast.h"

#include "ErrorGuard.h"
#include "hpx/codegenvisitor.hpp"
#include "hpx/programtree.hpp"
#include "hpx/programtreebuildingvisitor.hpp"
#include "hpx/symbolbuildingvisitor.hpp"
#include "hpx/symboltypes.hpp"

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <regex>
#include <streambuf>
#include <string>

#include <getopt.h> /* getopt API */

using namespace chpl;
using namespace uast;

extern char *optarg;
extern int optind, opterr, optopt;
const char *optstring;

static void generateSourceHeader(std::ostream &fos, std::string const &fps,
                                 std::filesystem::path const &chplFile) {
  fos << "// This program file was generated by the chplx compiler."
      << std::endl;
  fos << "// The original Chapel program file can be found here: "
      << std::filesystem::absolute(chplFile) << std::endl;
  fos << "//" << std::endl;

  fos << "#include <hpx/hpx_init.hpp>" << std::endl << std::endl;

  {
    const auto pos = fps.find(".");
    const std::string prefix = fps.substr(0, pos);
    fos << "#include \"" << prefix << ".hpp\"" << std::endl;
  }
}

static void generateSourceFooter(std::ostream &fos) {
  fos << std::endl
      << "int main(int argc, char ** argv) {" << std::endl
      << "    return hpx::init(argc, argv);" << std::endl
      << "}";
}

static void generateHpxMainBeg(std::ostream &fos) {
  fos << std::endl
      << "int hpx_main(int argc, char ** argv) {" << std::endl
      << std::endl;
}

static void generateHpxMainEnd(std::ostream &fos) {
  fos << std::endl
      << "    return hpx::finalize();" << std::endl
      << "}" << std::endl;
}

int main(int argc, char **argv) {

  Context context;
  Context *ctx = &context;
  ErrorGuard guard(ctx);

  std::optional<std::string> filePath{};

  // https://azrael.digipen.edu/~mmead/www/Courses/CS180/getopt.html
  //
  int opt = 0;

  // Retrieve the options:
  while ((opt = getopt(argc, argv, "f:h")) != -1) { // for each option...
    switch (opt) {
    case 'f':
      filePath = std::string{optarg};
      break;
    case 'h':
      std::cout
          << "chplx -help: `chplx -f <full path to file name or file name>`"
          << std::endl
          << std::flush;
      return 1;
      break;
    }
  }

  if (!filePath.has_value()) {
    std::cerr << "chplx : error, file not provided" << std::endl << std::flush;
    return 0;
  }

  std::filesystem::path chplFilePth{*filePath};
  {
    if (!std::filesystem::exists(chplFilePth)) {
      std::cerr << "chplx : error, file does not exist error\t" << *filePath
                << std::endl
                << std::flush;
      return 0;
    }
  }

  std::ifstream is(*filePath);
  if (!is.good()) {
    std::cerr << "chplx : error, file open error\t" << *filePath << std::endl
              << std::flush;
    return 0;
  }

  std::string fileContent((std::istreambuf_iterator<char>(is)),
                          std::istreambuf_iterator<char>());

  chpl::parsing::setFileText(ctx, *filePath, fileContent);

  uast::BuilderResult const &br = parsing::parseFileToBuilderResult(
      ctx, chpl::UniqueString::get(ctx, *filePath), {});

  for (auto &e : br.errors()) {
    ctx->report(e);
  }

  uast::Module const *mod = br.singleModule();

  // name resolution; turned off currently b/c it
  // requires adding the chapel standard library
  // as the 'prolog' to the compiler; however, the
  // chapel standard library contains compile time
  // generated code that includes OS and architecture
  // specific implementations
  //
  // need to figure out how multi-module name
  // resolution works
  //
  // const auto& rr =
  //   chpl::resolution::resolveModule(ctx, mod->id());

  const auto numErrors = guard.numErrors();

  if (numErrors > 0) {
    guard.realizeErrors();
  } else {

    std::string ofilePath{};
    {
      std::regex file_regex{R"([ \w-]+?(?=\.))"};
      auto words_begin =
          std::sregex_iterator(filePath->begin(), filePath->end(), file_regex);
      auto words_end = std::sregex_iterator();

      if (std::distance(words_begin, words_end) != 1) {
        std::cerr << "Invalid input file encountered\t" << *filePath
                  << std::endl;
        return -1;
      }

      std::smatch match = *words_begin;
      ofilePath = match.str() + ".cpp";
    }

    chplx::ast::hpx::ProgramTree program;

    chpl::ast::visitors::hpx::SymbolBuildingVisitor sbv{br, ofilePath};
    AstNode const *ast = static_cast<AstNode const *>(mod);
    ast->traverse(sbv);

    std::ofstream ofs(ofilePath);
    generateSourceHeader(ofs, ofilePath, chplFilePth);
    generateHpxMainBeg(ofs);

    chplx::ast::visitors::hpx::ProgramTreeBuildingVisitor pbv{
        {}, nullptr, 0, br, sbv.symbolTable, program, {&(program.statements)},
        {}};
    ast->traverse(pbv);

    chpl::ast::visitors::hpx::CodegenVisitor cgv{sbv.symbolTable, program, br,
                                                 ofilePath, ofs};
    cgv.indent += 1;
    cgv.visit();

    generateHpxMainEnd(ofs);
    generateSourceFooter(ofs);

    cgv.generateApplicationHeader();

    ofs.flush();
    ofs.close();
  }

  return 1;
}
