/*
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/cmakegen.hpp"
#include "hpx/utils.hpp"
#include <fstream>
#include <cassert>
#include <iostream>
#include <filesystem>
#include <fmt/core.h>

constexpr char const* CMakeListsTemplate = R"(#
# This program file was generated by the chplx compiler.
# The original Chapel program file can be found here: "{0}"
#
cmake_minimum_required(VERSION 3.19)
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Debug CACHE STRING "Configuration type" FORCE)
endif()

project({1})

add_executable({1} {1}.cpp {1}_driver.cpp)

set(CMAKE_CXX_STANDARD 20)
set(CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED YES)

include(CheckCXXCompilerFlag)
check_cxx_compiler_flag("-march=native" HAS_MARCH_NATIVE)

if(NOT Chplx_DIR)
  message(FATAL_ERROR "Chplx_DIR variable undefined")
endif()

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

find_package(fmt REQUIRED CONFIG)
find_package(HPX REQUIRED CONFIG)
find_package(Chplx REQUIRED CONFIG)

# pick the right “inline‐limit” flag
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  set(INLINE_LIMIT_FLAG "-finline-limit=1000")
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
  # clang uses an LLVM pass‐through flag
  set(INLINE_LIMIT_FLAG "-mllvm" "-inline-threshold=1000")
else()
  set(INLINE_LIMIT_FLAG "")
endif()

# only pass -march=native if supported
if (HAS_MARCH_NATIVE)
  set(MARCH_FLAG "-march=native")
else()
  set(MARCH_FLAG "")
endif()

target_link_libraries({1} PUBLIC fmt::fmt-header-only HPX::hpx Chplx::library)
set(CMAKE_CXX_FLAGS
    "${2} ${3} ${4} -flto")
)";

void CMakeGenerator::generate(std::filesystem::path const& p) {
    std::string cppfilename{p.filename().string()};
    auto pos = cppfilename.find(".chpl");
    assert(pos != std::string::npos);

    std::string incdirs_str{};
    std::string libdirs_str{};
    std::string libs_str{};
    std::string cxxflags_str{};
    std::string cmake_packages{};

    // process incdirs
    if(0 < chplx::util::incdirs.size()) {
        incdirs_str = "target_include_directories({1} PUBLIC \n";
        for(auto & incdir : chplx::util::incdirs) {
           incdirs_str += incdir.string() + "\n";
        }
        incdirs_str += ")";
    }

    // process libdirs
    if(0 < chplx::util::libdirs.size()) {
        for(auto & libdir : chplx::util::libdirs) {
           libdirs_str += libdir.string() + " ";
        }
    }

    // process libs
    if(0 < chplx::util::libs.size()) {
        for(auto & lib : chplx::util::libs) {
           libs_str += lib + " ";
        }
    }

    // process flagscxx
    if(0 < chplx::util::flagscxx.size()) {
        for(auto & cxxflag : chplx::util::flagscxx) {
           cxxflags_str += cxxflag + " "; 
        }
    }

    // process packages_cmake
    if(0 < chplx::util::packages_cmake.size()) {
        for(auto & cmake_pkg : chplx::util::packages_cmake) {
           cmake_packages += "find_package(" + cmake_pkg + " REQUIRED CONFIG)\n";
        }
    }
/*
    // process packages_pkgconfig
    if(0 < chplx::util::packages_pkgconfig.size()) {
        for(auto & incdir : chplx::util::packages_pkgconfig) {
           find_pkgconfig_package += "find_package(" + cmake_pkg + " REQUIRED CONFIG)"
        }
    }
*/
    const std::string cppprefix =
        cppfilename.substr(0, pos);

    std::filesystem::path opath = chplx::util::output_path / "CMakeLists.txt";
    std::ofstream ofs(opath.string());
    ofs << fmt::format(CMakeListsTemplate, cppfilename, cppprefix, "{CMAKE_CXX_FLAGS}", "{MARCH_FLAG}", "{INLINE_LIMIT_FLAG}");
}
