/*
 * Copyright (c) 2023 Christopher Taylor
 *
 * SPDX-License-Identifier: BSL-1.0
 * Distributed under the Boost Software License, Version 1.0. *(See accompanying
 * file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
#include "hpx/cmakegen.hpp"
#include "hpx/utils.hpp"
#include <fstream>
#include <cassert>
#include <iostream>
#include <filesystem>
#include <fmt/core.h>

constexpr char const* CMakeListsTemplate = R"(#
# This program file was generated by the chplx compiler.
# The original Chapel program file can be found here: "{0}"
#
cmake_minimum_required(VERSION 3.19)
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Debug CACHE STRING "Configuration type" FORCE)
endif()
project({1})
add_executable({1} {1}.cpp {1}_driver.cpp)
set(CMAKE_CXX_STANDARD 20)
set(CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED YES)
if(NOT WIN32 AND ${{CMAKE_CXX_COMPILER_ID}} STREQUAL "Clang" AND NOT APPLE)
  set(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} -std=c++20 -stdlib=libc++")
endif()
if(NOT Chplx_DIR)
  message(FATAL_ERROR "Chplx_DIR variable undefined")
endif()
set_property(GLOBAL PROPERTY USE_FOLDERS ON)
find_package(fmt REQUIRED CONFIG)
find_package(HPX REQUIRED CONFIG)
find_package(Chplx REQUIRED CONFIG)
set({1}_sources {1}.cpp {1}_driver.cpp)
set({1}_headers {1}.hpp {1}_driver.hpp)
if(NOT WIN32 AND ${{CMAKE_CXX_COMPILER_ID}} STREQUAL "Clang" AND APPLE)
  find_library(CORE_LIBPATH NAMES CoreFoundation REQUIRED)
  target_compile_options({1}
    PUBLIC
    -nostdlib
    -std=c++20
    -O3
    -stdlib=libc++
  )
  target_link_libraries({1} PRIVATE ${{CORE_LIBPATH}})
  target_link_libraries({1}
    PUBLIC
    c++
  )
endif()
target_link_libraries({1} PUBLIC fmt::fmt-header-only HPX::hpx Chplx::library)
enable_testing()
include(CTest)
add_test(
  NAME {1}_test
  COMMAND {1}
  WORKING_DIRECTORY $<TARGET_FILE_DIR:{1}>
)
)";

void CMakeGenerator::generate(std::filesystem::path const& p) {
    std::string cppfilename{p.filename().string()};
    auto pos = cppfilename.find(".chpl");
    assert(pos != std::string::npos);

    std::string incdirs_str{};
    std::string libdirs_str{};
    std::string libs_str{};
    std::string cxxflags_str{};
    std::string cmake_packages{};

    // process incdirs
    if(0 < chplx::util::incdirs.size()) {
        incdirs_str = "target_include_directories({1} PUBLIC \n";
        for(auto & incdir : chplx::util::incdirs) {
           incdirs_str += incdir.string() + "\n";
        }
        incdirs_str += ")";
    }

    // process libdirs
    if(0 < chplx::util::libdirs.size()) {
        for(auto & libdir : chplx::util::libdirs) {
           libdirs_str += libdir.string() + " ";
        }
    }

    // process libs
    if(0 < chplx::util::libs.size()) {
        for(auto & lib : chplx::util::libs) {
           libs_str += lib + " ";
        }
    }

    // process flagscxx
    if(0 < chplx::util::flagscxx.size()) {
        for(auto & cxxflag : chplx::util::flagscxx) {
           cxxflags_str += cxxflag + " "; 
        }
    }

    // process packages_cmake
    if(0 < chplx::util::packages_cmake.size()) {
        for(auto & cmake_pkg : chplx::util::packages_cmake) {
           cmake_packages += "find_package(" + cmake_pkg + " REQUIRED CONFIG)\n";
        }
    }
/*
    // process packages_pkgconfig
    if(0 < chplx::util::packages_pkgconfig.size()) {
        for(auto & incdir : chplx::util::packages_pkgconfig) {
           find_pkgconfig_package += "find_package(" + cmake_pkg + " REQUIRED CONFIG)"
        }
    }
*/
    const std::string cppprefix =
        cppfilename.substr(0, pos);

    std::filesystem::path opath = chplx::util::output_path / "CMakeLists.txt";
    std::ofstream ofs(opath.string());
    ofs << fmt::format(CMakeListsTemplate, cppfilename, cppprefix);
}
